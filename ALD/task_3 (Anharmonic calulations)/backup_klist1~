//COMPILE: g++ klist.cpp -fopenmp -g -Wall  -L/usr/local/lib -llapacke -llapack -lf77blas -lcblas -latlas -lgfortran -lm -lc

//=================STANDARD HEADER===================
#include <iostream>
#include <fstream>
#include <iomanip>
#include <math.h>
#include <stdio.h>
#include <ctime>    // For time()
#include <cstdlib>  // For srand() and rand()
#include <stdlib.h>
#include <complex.h>


//=========================GSL HEADER=================
//#include <gsl/gsl_matrix.h>
//#include <gsl/gsl_blas.h>
//#include <gsl/gsl_eigen.h>
//#include <gsl/gsl_complex.h>
//#include <gsl/gsl_complex_math.h>
//#include <gsl/gsl_math.h>
//#include <gsl/gsl_cblas.h>

//====================LAPACK HEADER==================
#include <lapack/lapacke.h>
extern "C" {
  #include <atlas/cblas.h>
}

using namespace std;

//=========================================================================================================================================================
//==========================================================================================================================================================
//======================INPUT/OUTPUT STREAMS=====================
ifstream data_in("input.dat");
ifstream phi2_in("PHI2.dat");
ifstream phi3_in("PHI3.dat");
ifstream phi4_in("PHI4.dat");
ofstream data_out("data.dat");
ofstream irorder2_out("IRBorder2.dat");
ofstream irorder3_out("IRBorder3.dat");
ofstream irorder4_out("IRBorder4.dat");
ofstream fullpos_out("FULLpos.dat");
ofstream fulldisp4_out("FULLorder4.dat");
ofstream fulldisp3_out("FULLorder3.dat");
ofstream fulldisp2_out("FULLorder2.dat");
//==============================================================


//======================STRUCTURE TYPES=========================
  struct lattice{                 //carries all information about the lattice
    float *r, *m, *R, ax, ay, az,*pos,*pR;             
    unsigned short int natom, ncell,Nx,Ny,Nz,nNx,nNy,nNz,type,isConv,nlist,kx,ky,kz,kx_scale,ky_scale,kz_scale,nNeighbour2,nNeighbour3,nNeighbour4;
    unsigned int *index;
  };

  struct disp{                   // useful for creating and storing irreducible list of force constant, etc
    float *order2, *order3, *order4;
    unsigned long int *iorder2, *iorder3, *iorder4;
    unsigned int norder2,norder3,norder4;
  };

  struct dyna{                 //stores force constant and other information related with force constant like frequency, etc.
    float *order2, *order3, *order4;
    float complex *eigvec;
    float *freq;
    unsigned int *iorder2, *iorder3, *iorder4,norder2,norder3,norder4;
    float *linewidth, *epsi;
    float *velocity;
    unsigned int *info2, *info3, *info4;
    float *pos2, *pos3, *pos4, *m2, *m3, *m4;
  };
//===============================================================

//=====================FUNCTION PROTOTYPES=======================
void sub_realStructure(lattice *realLattice);
void sub_klist(float *klist,lattice *realLattice);
int sub_kinteraction(float *klist,lattice *realLattice, float *kinterac,unsigned short int *ikinterac);
int sub_search(long int *sklist,int s, int e,long int tmp);
void sub_irrdisList(lattice *realLattice, disp *irrdisp);
void sub_posIndex(lattice *realLattice);
unsigned long int sub_Iorder4(unsigned int r1,unsigned int r2,unsigned int r3,unsigned int d1,unsigned int d2,unsigned int d3);
unsigned long int sub_Iorder3(unsigned int r1,unsigned int r2,unsigned int d1,unsigned int d2);
unsigned long int sub_Iorder2(unsigned int r1,unsigned int d1);
void sub_fulldisp(lattice *realLattice,dyna *dynamic);
void sub_posPrimitive(lattice *realLattice);
void sub_eigen(lattice *realLattice, dyna *dynamic,float *klist);
void sub_linewidth(lattice *realLattice, dyna *dynamic, float *klist, unsigned short int *ikinterac,unsigned int ninterac, int iteration);
inline float complex sub_phi(float k1[3], float k2[3],float k3[3], dyna *dynamic, float complex e1[36],float complex e2[36],float complex e3[36],float w1[6],float w2[6],float w3[6] ,int nu1,int nu2, int nu3);
float sub_fdelta(unsigned int i1,unsigned int i2,unsigned int i3,unsigned int nu1,unsigned int nu2,unsigned int nu3,dyna *dynamic);
float sub_delta(float w,float e);
float sub_nbe(float w);
void sub_epsi(dyna *dynamic,int i, lattice *realLattice);
void sub_readPhi(dyna *dynamic);
void sub_kscale(float *klist,lattice *realLattice);
void sub_info(lattice *realLattice, dyna *dynamic);
//===============================================================

//=============global variables=================================
const float pi = 3.14159265;
int numthread;
float temperature;
const float hbar = 6.626068*(1e-34)/(pi);
const float Kb = 1.3806503*(1e-23);
int FC_available;
//=================================================================

//===========================================================================================================================================================
//===========================================================================================================================================================
int main(){
  clock_t start, end,start1,end1;
  double cpuTime;
  start = clock();
  start1=start;

  //================ variable declaration=======================================================
  lattice *realLattice;
  float *klist;
  float *kinterac,fos_kinterac;
  unsigned int ninterac;
  unsigned short int *ikinterac;
  disp *irrdisp;
  dyna *dynamic;
  //=============================================================================================
  
  //=========READING INPUTS AND DEVELOPING STRUCTURE=============================================
  realLattice = new lattice;
  sub_realStructure(realLattice);

  end = clock();
  cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
  start = clock();
  cout<<"Structure created in "<<cpuTime<<" seconds."<<endl;
  //================================================================================================

  //======================= DEVELOPING RECIPROCAL SPACE VECTORS=====================================
  if(FC_available==1){
    klist = new float [realLattice->nlist*3];
    sub_klist(klist,realLattice);

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"Reciprocal vectors created in "<<cpuTime<<" seconds."<<endl;
  }
  //=================================================================================================

 
  //============== CHECKING ALLOWED K COMBINATIONS K1 + K2 = K3 +G  ====================================
  if(FC_available==1){
    fos_kinterac = 0.7;
    //kinterac = new float [lround(fos_kinterac*((realLattice->nlist)*(realLattice->nlist)))*9];
    ikinterac = new unsigned short int [lround(fos_kinterac*((realLattice->nlist)*(realLattice->nlist)))*3];
    ninterac = sub_kinteraction(klist,realLattice,kinterac,ikinterac);
    

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"Allowed K points checked in "<<cpuTime<<" seconds."<<endl;
  }
  //===================================================================================================

  //============ Generating and writing full force constant list and index list======================
  dynamic = new dyna;
  sub_posIndex(realLattice);              // writing position file in increasing distance from origin
  sub_fulldisp(realLattice,dynamic);                 // full 2nd, 3rd and 4th order displacement list
  sub_posPrimitive(realLattice);           // primitive cells for dynamic matrix

  end = clock();
  cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
  start = clock();
  cout<<"Full displacement list created in "<<cpuTime<<" seconds."<<endl;
  //====================================================================================================
  
  //======GENERATING IRREDUCIBLE NUMBER OF DISPLACEMENT LIST FOR FORCE CONSTANTS=====================
  irrdisp = new disp;
  sub_irrdisList(realLattice,irrdisp);                     // calculate the irreducible displacements

  end = clock();
  cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
  start = clock();
  cout<<"Irreducible list created in "<<cpuTime<<" seconds."<<endl;
  //=================================================================================================

  //=========READING FORCE CONSTANTS FROM FILE=======================================================
  if(FC_available==1){
    sub_readPhi(dynamic);

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"FCs read in "<<cpuTime<<" seconds."<<endl;
  }
  //=================================================================================================

  //===============creating info list (to get rid of array of array)=================================
  if(FC_available==1){
    sub_info(realLattice,dynamic);

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"Info list created in "<<cpuTime<<" seconds."<<endl;
  }
  //===================================================================================================

  //=========Scaling k values to real values=======================================================
  if(FC_available==1){
    sub_kscale(klist,realLattice);

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"K values scaled in "<<cpuTime<<" seconds."<<endl;
  }
  //=================================================================================================

  //========calculating eigen vectors and frequencies for all k points==============================
  if(FC_available==1){
    sub_eigen(realLattice,dynamic,klist);       //calculates eigen vectors and eigen values for all k points

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"Eigen vectors and values calculated in "<<cpuTime<<" seconds."<<endl;
  }
  //================================================================================================

  
  //================solving for linewidths===================
  if(FC_available==1){
    for(int i=0;i<1;i++){
      sub_epsi(dynamic,i,realLattice);
      sub_linewidth(realLattice, dynamic, klist, ikinterac,ninterac,i);
    }

    end = clock();
    cpuTime= (end-start)/ (double) (CLOCKS_PER_SEC);
    start = clock();
    cout<<"linewidths for different interactions (egn 16) calculated in "<<cpuTime<<" seconds."<<endl;
  }
  //================================================================================================

  
  end = clock();
  end1=end;
  cpuTime= (end1-start1)/ (double) (CLOCKS_PER_SEC);
  cout<<"TOTAL TIME IS "<<cpuTime<<" SECONDS."<<endl;
}



//========== FUNCTIONS===========================================================================================================================

//---------------------------identity of 4th order force constant (Irreducible)---------------------------------------------------------------------
unsigned long int sub_Iorder4(unsigned int r1,unsigned int r2,unsigned int r3,unsigned int d1,unsigned int d2,unsigned int d3){
  unsigned int r0,d0,tr1,tr2,tr3,tr0,nequal,type0,type1,type2,tmpd,t0,t1,t2,t3,tmpd2,tmpd3,type3,type4,type5;
  unsigned long int m,mtype1,mtype2,mrep0,mtype0,mequal,norder4,tm,md,norder3,norder2,mtype3,mtype4,mtype5;
  bool check,check1,check2;
  
  r0 = 0; d0=1;
  t0=11;
  mtype0 = 10; mtype1 = 100; mtype2 = 1000; mequal = 10000; mrep0 =1000000;md = 100000;

  type0=1;type1=0;type2=0;m=0;nequal=0;tr0=1;tr1=1;tr2=1;tr3=1;
  if(r1==0) {type0++; t1=11;}
  if(r2==0) {type0++; t2=11;}
  if(r3==0) {type0++; t3=11;}
  if((r1>0)&&(r1<5)) {type1++; t1=12;}
  if((r2>0)&&(r2<5)) {type1++; t2=12;}
  if((r3>0)&&(r3<5)) {type1++; t3=12;}
  if(r1>4) {type2++; t1=13;}
  if(r2>4) {type2++; t2=13;}
  if(r3>4) {type2++; t3=13;}
  m = mtype0*type0 + mtype1*type1 + mtype2*type2;

  if(r0==r1) {nequal++; tr0++;tr1++;}
  if(r0==r2) {nequal++; tr0++;tr2++;}
  if(r0==r3) {nequal++; tr0++;tr3++;}
  if(r1==r2) {nequal++; tr1++;tr2++;}
  if(r1==r3) {nequal++; tr1++;tr3++;}
  if(r2==r3) {nequal++; tr2++;tr3++;}
  m = m + mequal*nequal;

  tm =0;
  tmpd=1; check1=true;check2=true;
  if(d1==1){
  if(d2==1){
  if(d3!=1) d3=2;
    }else{
      tmpd=d2;
      d2=2;
      if((d3!=1)&&(d3!=tmpd)) {d3 = 3;check1=false;}
      if((d3==tmpd)&&(check1==true)) d3=2;
    }
  }else{
    tmpd=d1;
    d1=2;
    if((d2!=1)&&(d2!=tmpd)) {d2=3; check1=false;}
    if((d3!=1)&&(d3!=tmpd)) {d3=3; check2=false;}
    if((d2==tmpd)&&(check1==true)) d2=2;
    if((d3==tmpd)&&(check2==true)) d3=2;
  }
  tmpd=1;
  if(d1>tmpd) tmpd = d1;
  if(d2>tmpd) tmpd = d2;
  if(d3>tmpd) tmpd = d3;
  tmpd2=0;tmpd3=0;
  if(tmpd==3){
    if(d1==2)tmpd2++;
    if(d1==3)tmpd3++;
    if(d2==2)tmpd2++;
    if(d2==3)tmpd3++;
    if(d3==2)tmpd2++;
    if(d3==3)tmpd3++;
    check=true;check1=true;check2=true;
    if(tmpd3>tmpd2){
      if(d1==2){d1=3;check=false;}
      if(d2==2){d2=3;check1=false;}
      if(d3==2){d3=3;check2=false;}
      if(check&&(d1==3)) d1=2;
      if(check1&&(d2==3)) d2=2;
      if(check2&&(d3==3)) d3=2;
    }
  }
  tm = tmpd*md;
  tm = tm + (mrep0)*(((tr0*1000 + 100*t0)*d0) + ((tr1*1000 + 100*t1)*d1) + ((tr2*1000+100*t2)*d2) + ((tr3*1000+100*t3)*d3));
  tm = m +tm;
  return tm;
}
//---------------------------------------------------------------------------------------------------------------------------

//---------------------------identity of 3rd order force constant (Irreducible)---------------------------------------------------------------------
unsigned long int sub_Iorder3(unsigned int r1,unsigned int r2,unsigned int d1,unsigned int d2){
  unsigned int r0,d0,tr1,tr2,tr3,tr0,nequal,type0,type1,type2,tmpd,t0,t1,t2,t3,tmpd2,tmpd3,type3,type4,type5;
  unsigned long int m,mtype1,mtype2,mrep0,mtype0,mequal,norder4,tm,md,norder3,norder2,mtype3,mtype4,mtype5;
  bool check,check1,check2;

  r0 = 0; d0=1;
  t0=11;
  mtype0 = 10; mtype1 = 100; mtype2 = 1000; mequal = 10000; mrep0 =1000000;md = 100000;

  type0=1;type1=0;type2=0;m=0;nequal=0;tr0=1;tr1=1;tr2=1;
  if(r1==0) {type0++; t1=11;}
  if(r2==0) {type0++; t2=11;}
  if((r1>0)&&(r1<5)) {type1++; t1=12;}
  if((r2>0)&&(r2<5)) {type1++; t2=12;}
  if(r1>4) {type2++; t1=13;}
  if(r2>4) {type2++; t2=13;}
  m = mtype0*type0 + mtype1*type1 + mtype2*type2;

  if(r0==r1) {nequal++; tr0++;tr1++;}
  if(r0==r2) {nequal++; tr0++;tr2++;}
  if(r1==r2) {nequal++; tr1++;tr2++;}
  m = m + mequal*nequal;

  tm =0;
  tmpd=1; check1=true;
  if(d1==1){
    if(d2!=1){
      tmpd=d2;
      d2=2;
    }
  }else{
    tmpd=d1;
    d1=2;
    if((d2!=1)&&(d2!=tmpd)) {d2=3; check1=false;}
    if((d2==tmpd)&&(check1==true)) d2=2;
  }
  tmpd=1;
  if(d1>tmpd) tmpd = d1;
  if(d2>tmpd) tmpd = d2;
  tmpd2=0;tmpd3=0;
  if(tmpd==3){
    if(d1==2)tmpd2++;
    if(d1==3)tmpd3++;
    if(d2==2)tmpd2++;
    if(d2==3)tmpd3++;
    check=true;check1=true;
    if(tmpd3>tmpd2){
      if(d1==2){d1=3;check=false;}
      if(d2==2){d2=3;check1=false;}
      if(check&&(d1==3)) d1=2;
      if(check1&&(d2==3)) d2=2;
    }
  }
  tm = tmpd*md;
  tm = tm + (mrep0)*(((tr0*1000 + 100*t0)*d0) + ((tr1*1000 + 100*t1)*d1) + ((tr2*1000+100*t2)*d2) );
  tm = m+tm;
  return tm;
}
//---------------------------------------------------------------------------------------------------------------------------

//---------------------------identity of 2nd order force constant (Irreducible)--------------------------------------------------------------------
unsigned long int sub_Iorder2(unsigned int r1,unsigned int d1){
  unsigned int r0,d0,tr1,tr2,tr3,tr0,nequal,type0,type1,type2,tmpd,t0,t1,t2,t3,tmpd2,tmpd3,type3,type4,type5;
  unsigned long int m,mtype1,mtype2,mrep0,mtype0,mequal,norder4,tm,md,norder3,norder2,mtype3,mtype4,mtype5;
  bool check,check1,check2;

  r0 = 0; d0=1;
  t0=11;
  mtype0 = 10; mtype1 = 100; mtype2 = 1000;mtype3 = 10000; mtype4 = 100000;mtype5 =1000000; mequal = 10000000; mrep0 =100000000000;md = 1000000000;

  type0=1;type1=0;type2=0;m=0;nequal=0;tr0=1;tr1=1;type3=0;type4=0;type5=0;
  if(r1==0) {type0++; t1=11;}
  if((r1>0)&&(r1<5)) {type1++; t1=12;}
  if((r1>4)&&(r1<17)) {type2++; t1=13;}
  if((r1>16)&&(r1<29)) {type3++; t1=14;}
  if((r1>28)&&(r1<35)) {type4++; t1=15;}
  if((r1>34)&&(r1<47)) {type5++; t1=16;}
  m = mtype0*type0 + mtype1*type1 + mtype2*type2 + mtype3*type3 + mtype4*type4 + mtype5*type5;

  if(r0==r1) {nequal++; tr0++;tr1++;}
  m = m + mequal*nequal;
  tm =0;
  tmpd=1;
  if(d1!=1){
    tmpd=d1;
    d1=2;
  }
  tmpd=1;
  if(d1>tmpd) tmpd = d1;
  tmpd2=0;tmpd3=0;
  if(tmpd==3){
    if(d1==2)tmpd2++;
    if(d1==3)tmpd3++;
    check=true;
    if(tmpd3>tmpd2){
      if(d1==2){d1=3;check=false;}
      if(check&&(d1==3)) d1=2;
    }
  }
  tm = tmpd*md;
  tm = tm + (mrep0)*(((tr0*1000 + 100*t0)*d0) + ((tr1*1000 + 100*t1)*d1) );
  tm = m+tm;
  return tm;
}
//---------------------------------------------------------------------------------------------------------------------------

//--------counting and CREATING  DISPLACEMENT LIST FOR 2ND, 3RD AND 4TH ORDER FORCE CONSTANTS (Irreducible)--------------------
void sub_irrdisList(lattice *realLattice, disp *irrdisp){
  //this subroutine assumes fcc diamond structure with same type of atoms....i.e., all atoms are identical.....
  
  unsigned int nnbh_cutoff,r1,r2,r3,r0,d1,d2,d3,d0;
  unsigned long int tm,norder4,norder3,norder2;
  bool check;
  r0 = 0; d0=1;

  /*  forth order force constant calculation */
  //==========================================fourth order==============================================================================
  // iorder4 have first 4 columns as atom types and 5-8 columns as displacement types and finally 9th column as its identity...
  nnbh_cutoff = realLattice->nNeighbour4;
  if(nnbh_cutoff==2) nnbh_cutoff = 1 + 4 + 12;       // 1 central atom + 4 1st neighbour + 12 2nd nearest neighbour
  if(nnbh_cutoff==1) nnbh_cutoff = 1 + 4;
  norder4=0;
  irrdisp->iorder4 = new unsigned long int [200*9];
  
  //atom types
  for(int i1=0;i1<nnbh_cutoff;i1++){
    r1 = i1;
    for(int i2=0;i2<nnbh_cutoff;i2++){
      r2 = i2;
      for(int i3=0;i3<nnbh_cutoff;i3++){
	r3 = i3;
	for(int i4=1;i4<4;i4++){
	  d1 = i4;
	  for(int i5=1;i5<4;i5++){
	    d2 = i5;
	    for(int i6=1;i6<4;i6++){
	      d3 = i6;
	      
	      tm = sub_Iorder4(r1,r2,r3,d1,d2,d3);
	      check=true;
	      for(int z=0;z<norder4;z++){
		if(irrdisp->iorder4[9*z+8]==tm){
		  check=false;
		}
	      }
	      if(check==true){
		irrdisp->iorder4[9*norder4+8]=tm;
		irrdisp->iorder4[9*norder4+0]=r0;
		irrdisp->iorder4[9*norder4+1]=r1;
		irrdisp->iorder4[9*norder4+2]=r2;
		irrdisp->iorder4[9*norder4+3]=r3;
		irrdisp->iorder4[9*norder4+4]=d0;
		irrdisp->iorder4[9*norder4+5]=d1;
		irrdisp->iorder4[9*norder4+6]=d2;
		irrdisp->iorder4[9*norder4+7]=d3;
		norder4++;
	      }
	    }
	  }
	}
      }
    }
  }irrdisp->norder4 = norder4;
  //cout<<norder4<<endl;
  //======================================================================================================================================


  //======================== third order==================================================================================================
  nnbh_cutoff = realLattice->nNeighbour3;
  if(nnbh_cutoff==2) nnbh_cutoff = 1 + 4 + 12;       // 1 central atom + 4 1st neighbour + 12 2nd nearest neighbour
  if(nnbh_cutoff==1) nnbh_cutoff = 1 + 4;
  norder3=0;
  irrdisp->iorder3 = new unsigned long int [200*7];

  //atom types
  for(int i1=0;i1<nnbh_cutoff;i1++){
    r1 = i1;
    for(int i2=0;i2<nnbh_cutoff;i2++){
      r2 = i2;
	for(int i4=1;i4<4;i4++){
	  d1 = i4;
	  for(int i5=1;i5<4;i5++){
	    d2 = i5;
	    
	      tm = sub_Iorder3(r1,r2,d1,d2);
	      check=true;
	      for(int z=0;z<norder3;z++){
		if(irrdisp->iorder3[7*z+6]==tm){
		  check=false;
		}
	      }
	      if(check==true){
		irrdisp->iorder3[7*norder3+6]=tm;
		irrdisp->iorder3[7*norder3+0]=r0;
		irrdisp->iorder3[7*norder3+1]=r1;
		irrdisp->iorder3[7*norder3+2]=r2;
		irrdisp->iorder3[7*norder3+3]=d0;
		irrdisp->iorder3[7*norder3+4]=d1;
		irrdisp->iorder3[7*norder3+5]=d2;
		norder3++;
	      }
	    }
	  }
	}
      }irrdisp->norder3 = norder3;
  //cout<<norder3<<endl;
  //======================================================================================================================================


  //======================== second order==================================================================================================
  nnbh_cutoff = realLattice->nNeighbour2;
  if(nnbh_cutoff==1) nnbh_cutoff = 1 + 4 ;       // 1 central atom + 4 1st neighbour + 12 2nd nearest neighbour
  if(nnbh_cutoff==2) nnbh_cutoff = 1 + 4 + 12;
  if(nnbh_cutoff==3) nnbh_cutoff = 1 + 4 + 12 + 12;
  if(nnbh_cutoff==4) nnbh_cutoff = 1 + 4 +12 +12 +6;
  if(nnbh_cutoff==5) nnbh_cutoff = 1 + 4 + 12 +12+6+12;
  norder2=0;
  irrdisp->iorder2 = new unsigned long int [200*5];
  

  //atom types
  for(int i1=0;i1<nnbh_cutoff;i1++){
    r1 = i1;
    //directions
    for(int i4=1;i4<4;i4++){
      d1 = i4;
	      tm = sub_Iorder2(r1,d1);
	      check=true;
	      for(int z=0;z<norder2;z++){
		if(irrdisp->iorder2[5*z+4]==tm){
		  check=false;
		}
	      }
	      if(check==true){
		irrdisp->iorder2[5*norder2+4]=tm;
		irrdisp->iorder2[5*norder2+0]=r0;
		irrdisp->iorder2[5*norder2+1]=r1;
		irrdisp->iorder2[5*norder2+2]=d0;
		irrdisp->iorder2[5*norder2+3]=d1;
		norder2++;
	      }
	    }
	  }irrdisp->norder2 = norder2;
  //cout<<norder2<<endl;
  //======================================================================================================================================

  //........................................................................
  //....writing 2nd order.....
  for(int i=0;i<irrdisp->norder2;i++){
    irorder2_out<<irrdisp->iorder2[5*i+0]<<'\t';
    irorder2_out<<(irrdisp->iorder2[5*i+1])<<'\t';
    irorder2_out<<irrdisp->iorder2[5*i+2]<<'\t'<<irrdisp->iorder2[5*i+3]<<endl;
  }

  //....writing 3rd order.....
  for(int i=0;i<irrdisp->norder3;i++){
    irorder3_out<<(irrdisp->iorder3[7*i+0])<<'\t'<<(irrdisp->iorder3[7*i+1])<<'\t'<<(irrdisp->iorder3[7*i+2])<<'\t'<<irrdisp->iorder3[7*i+3]<<'\t'<<irrdisp->iorder3[7*i+4]<<'\t'<<irrdisp->iorder3[7*i+5]<<endl;
  }

  //....writing 4th order.....
  for(int i=0;i<irrdisp->norder4;i++){
    irorder4_out<<(irrdisp->iorder4[9*i+0])<<'\t';
    irorder4_out<<(irrdisp->iorder4[9*i+1])<<'\t';
    irorder4_out<<(irrdisp->iorder4[9*i+2])<<'\t';
    irorder4_out<<(irrdisp->iorder4[9*i+3])<<'\t';
    irorder4_out<<irrdisp->iorder4[9*i+4]<<'\t'<<irrdisp->iorder4[9*i+5]<<'\t'<<irrdisp->iorder4[9*i+6]<<'\t'<<irrdisp->iorder4[9*i+7]<<'\n';
  }
}
//----------------------------------------------------------------------------------------------------------------------------------------------

//------calculating phi for one particular combination of interaction--------------------------------------------------------
inline float complex sub_phi( float k1[3], float k2[3],float k3[3], dyna *dynamic, float complex e1[36],float complex e2[36],float complex e3[36],float w1[6],float w2[6],float w3[6],int nu1,int nu2, int nu3){
  float complex phi;
  float complex tt,p2n1,p2n2,p2n3,p31,p32;
  float p2d1,p2d2,p2d3;
  tt = 1I;
  phi = 0.;
  
  for(int i=0;i<dynamic->norder3;i++){
    p2n1 = e1[6*(3*(dynamic->info3[3*i+0])+dynamic->iorder3[6*i+3]-1) + nu1] * (cexp(tt*((k1[0]*(dynamic->pos3[9*i + 3*0 + 0]))+(k1[1]*(dynamic->pos3[9*i + 3*0 + 1]))+(k1[2]*(dynamic->pos3[9*i + 3*0 + 2])))));
    p2n2 = e2[6*(3*(dynamic->info3[3*i+1])+dynamic->iorder3[6*i+4]-1) + nu2] * (cexp(tt*((k2[0]*(dynamic->pos3[9*i + 3*1 + 0]))+(k2[1]*(dynamic->pos3[9*i + 3*1 + 1]))+(k2[2]*(dynamic->pos3[9*i + 3*1 + 2])))));
    p2n3 = e3[6*(3*(dynamic->info3[3*i+2])+dynamic->iorder3[6*i+5]-1) + nu3] * (cexp(tt*((k3[0]*(dynamic->pos3[9*i + 3*2 + 0]))+(k3[1]*(dynamic->pos3[9*i + 3*2 + 1]))+(k3[2]*(dynamic->pos3[9*i + 3*2 + 2])))));
    p2d1 = dynamic->m3[3*i+0] * w1[nu1];
    p2d2 = dynamic->m3[3*i+1] * w2[nu2];
    p2d3 = dynamic->m3[3*i+2] * w3[nu3];
    phi += (dynamic->order3[i]) * (p2n1*p2n2*p2n3/sqrt(p2d1*p2d2*p2d3));
  }
  return phi;
}
//--------------------------------------------------------------------------------------------------------------------------------------------

//----------calculating epsilon for delta function----------------------------------------------------------------------------
void sub_epsi(dyna *dynamic,int iteration, lattice *realLattice){
  float epsi0;
  epsi0 = 1;
  
  if(iteration==0) {
    dynamic->epsi = new float [realLattice->nlist*6];
    for(int k=0;k<realLattice->nlist;k++){
      for(int i=0;i<6;i++){
	dynamic->epsi[6*k+i] = epsi0;
      }
    }
  }else{
    for(int k=0;k<realLattice->nlist;k++){
      for(int i=0;i<6;i++){
	dynamic->epsi[6*k+i] = dynamic->linewidth[6*k+i];
      }
    }
  }
  
}
//---------------------------------------------------------------------------------------------------------------------------

//----bose einstein occupation number-----------------------------------------------------------------------------------------
float sub_nbe(float w){
  float result;
  result = 1./((exp(hbar*w/(Kb*temperature)))-1);
}
//-----------------------------------------------------------------------------------------------------------------------------------

//-----------delta function-------------------------------------------------------------------------------------------------------
float sub_delta(float w,float e){
  float result;
  result = (1/pi)*(e/(w*w+e*e));
  return result;
}
//---------------------------------------------------------------------------------------------------------------------------------

//-----------bose einstien times delta function--------------------------------------------------------------------------------
float sub_fdelta(unsigned int i1,unsigned int i2,unsigned int i3,unsigned int nu1,unsigned int nu2,unsigned int nu3,dyna *dynamic){
  float result,w1,w2,w3,e;
  w1 = dynamic->freq[6*i1+nu1];
  w2 = dynamic->freq[6*i2+nu2];
  w3 = dynamic->freq[6*i3+nu3];

  e = dynamic->epsi[6*i1+nu1] + dynamic->epsi[6*i2+nu2] + dynamic->epsi[6*i3+nu3];
  

  result = ((sub_nbe(w2) + sub_nbe(w3) + 1)*(sub_delta(w1-w2-w3,e))) + ((sub_nbe(w2) - sub_nbe(w3))*(sub_delta(w1+w2-w3,e) - sub_delta(w1-w2+w3,e)));
  return result;
}
//------------------------------------------------------------------------------------------------------------------------------

//------calculating linewidth (eqn 16 in prb 2009) for different allowable combinations of k1,k2,k3
void sub_linewidth(lattice *realLattice, dyna *dynamic, float *klist, unsigned short int *ikinterac,unsigned int ninterac, int iteration){
  if(iteration==0) dynamic->linewidth = new float [6*realLattice->nlist];
  int i,nu1,nu2,nu3,i1,i2,i3;
  float tmp,check,tmp1;
  check=1e-20;
  float k1[3],k2[3],k3[3];
  float complex e1[36],e2[36],e3[36];
  float w1[6],w2[6],w3[6];

  for( i=0;i<6*realLattice->nlist;i++){
    dynamic->linewidth[i] = 0;
  }

#pragma omp parallel for private(i,nu1,nu2,nu3,tmp,tmp1,i1,i2,i3,e1,e2,e3,w1,w2,w3,k1,k2,k3) num_threads(numthread)
  for( i=0;i<ninterac;i++){
    i1 = ikinterac[3*i+0];
    i2 = ikinterac[3*i+1];
    i3 = ikinterac[3*i+2];
    k1[0] = klist[3*i1+0]; k1[1] = klist[3*i1+1]; k1[2] = klist[3*i1+2];
    k2[0] = klist[3*i2+0]; k2[1] = klist[3*i2+1]; k2[2] = klist[3*i2+2];
    k3[0] = klist[3*i3+0]; k3[1] = klist[3*i3+1]; k3[2] = klist[3*i3+2];
    for(int j=0;j<36;j++){
      e1[j] = dynamic->eigvec[36*i1+j];
      e2[j] = dynamic->eigvec[36*i2+j];
      e3[j] = dynamic->eigvec[36*i3+j];
    }
    for(int j=0;j<6;j++){
      w1[j] = dynamic->freq[6*i1+j];
      w2[j] = dynamic->freq[6*i2+j];
      w3[j] = dynamic->freq[6*i3+j];
    }

 
    if((i1==i2)&&(i2==i3)){   // k1=k2=k3
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i2,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check)))  tmp1 = cabs(sub_phi(k1,k2,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
    }

/*   
    if((i1==i2)&&(i2!=i3)){   //k1=k2!=k3
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i2,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k2,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for(nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i3,i2,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k3,k2,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for(nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for(nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i3,i2,i1,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k3,k2,k1,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i3 + nu1] += tmp;
	  }
	}
      }
    }
 
    if((i1!=i2)&&(i2==i3)){   //k1!=k2=k3
      for(nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for(nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i2,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k2,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for(nu2=0;nu2<6;nu2++){
	  for(nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i2,i1,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k2,k1,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i2 + nu1] += tmp;
	  }
	}
      }
      for(nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i3,i2,i1,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k3,k2,k1,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i3 + nu1] += tmp;
	  }
	}
      }
    }

    
    if((i1==i3)&&(i2!=i3)){   //k1=k3!=k2
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i2,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k2,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for(nu1=0;nu1<6;nu1++){
	for(nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i3,i2,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k3,k2,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i2,i1,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1 = cabs(sub_phi(k2,k1,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i2 + nu1] += tmp;
	  }
	}
      }
    }

    
    if((i1!=i2)&&(i2!=i3)&&(i1!=i3)){  //k1!=k2!=k3
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i2,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k2,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i1,i3,i2,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k1,k3,k2,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i1 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i2,i1,i3,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k2,k1,k3,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i2 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i2,i3,i1,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k2,k3,k1,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i2 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i3,i2,i1,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k3,k2,k1,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i3 + nu1] += tmp;
	  }
	}
      }
      for( nu1=0;nu1<6;nu1++){
	for( nu2=0;nu2<6;nu2++){
	  for( nu3=0;nu3<6;nu3++){
	    tmp = sub_fdelta(i3,i1,i2,nu1,nu2,nu3,dynamic);
	    tmp1=0;
	    if((tmp>check)||(tmp<(-check))) tmp1  = cabs(sub_phi(k3,k1,k2,dynamic,e1,e2,e3,w1,w2,w3,nu1,nu2,nu3));
	    tmp = tmp*tmp1*tmp1;
	    dynamic->linewidth[6*i3 + nu1] += tmp;
	  }
	}
      }
    }
*/
    
  }
}
//-----------------------------------------------------------------------------------------------------------------------------------------

//-------calculating eigen values and eigen vectors---------------------------------------------------------------------------
void sub_eigen(lattice *realLattice, dyna *dynamic,float *klist){
  //specific to diamond structure only with primitive unit cell
  float vec[36];              //temporary eigen vector
  float val[6];               // temporary eigen value
  float kx,ky,kz,px,py,pz;
  int x,y,info,i,k;
  float m1,m2;
  float complex tt;
  tt = 1I;

  dynamic->freq = new float [6*realLattice->nlist];         //6 branches for diamond structure with primitive cell
  dynamic->eigvec = new float complex [36*realLattice->nlist];
  float complex *tmpdynax, *tmpdynay, *tmpdynaz;
  tmpdynax = new float complex [36*realLattice->nlist];
  tmpdynay = new float complex [36*realLattice->nlist];
  tmpdynaz = new float complex [36*realLattice->nlist];

  
  for(k=0;k<realLattice->nlist;k++){
    for(i=0;i<36;i++){
      dynamic->eigvec[36*k+i]=0;
      tmpdynax[36*k+i] = 0;
      tmpdynay[36*k+i] = 0;
      tmpdynaz[36*k+i] = 0;
    }
  }

  // creating dynamic matrices for all k points
    for(i=0;i<dynamic->norder2;i++){
      x = (3*(realLattice->index[2*dynamic->iorder2[4*i+0] + 1])+dynamic->iorder2[4*i+2]-1);
      y = (3*(realLattice->index[2*dynamic->iorder2[4*i+1] + 1])+dynamic->iorder2[4*i+3]-1);
      px = (dynamic->pos2[6*i+3*1+0] -dynamic->pos2[6*i+3*0+0]);
      py = (dynamic->pos2[6*i+3*1+1]- dynamic->pos2[6*i+3*0+1]);
      pz = (dynamic->pos2[6*i+3*1+2]- dynamic->pos2[6*i+3*0+2]);
      m1 = dynamic->m2[2*i+0];
      m2 = dynamic->m2[2*i+1];
      m1 = 1./(sqrt(m1*m2));
      
#pragma omp parallel for private(k,kx,ky,kz) num_threads(numthread)
      for(k=0;k<realLattice->nlist;k++){
	kx = klist[3*k+0]; ky = klist[3*k+1]; kz = klist[3*k+2];
	dynamic->eigvec[36*k + 6*x + y] += ((m1 * (dynamic->order2[i])))* (cexpf((tt)*(((kx*px)+(ky*py)+(kz*pz)))));
      }
    }

    
    // solving eigen value problem
#pragma omp parallel for private(k,info) num_threads(numthread)
    for(k=0;k<realLattice->nlist;k++){
      info = LAPACKE_cheev(LAPACK_ROW_MAJOR, 'V', 'U',6,&dynamic->eigvec[36*k],6,&dynamic->freq[6*k]);
      if(info!=0) cout<<"ERROR: failed to solve for eigen values and eigenvectors."<<endl;
    }

    // frequencies from eigen values
    for(k=0;k<realLattice->nlist;k++){
      data_out<<klist[3*k+0]<<'\t'<<klist[3*k+1]<<'\t'<<klist[3*k+2]<<'\t';
      for(i=0;i<6;i++){
	dynamic->freq[6*k+i] = (dynamic->freq[6*k+i]>0)?(sqrt(dynamic->freq[6*k+i])):(0);
	data_out<<dynamic->freq[6*k+i]<<'\t';
      }
      data_out<<endl;
    }

    
    // group velocities
    dynamic->velocity = new float [realLattice->nlist*6*3];
    for(i=0;i<dynamic->norder2;i++){
      x = (3*(realLattice->index[2*dynamic->iorder2[4*i+0] + 1])+dynamic->iorder2[4*i+2]-1);
      y=(3*(realLattice->index[2*dynamic->iorder2[4*i+1] + 1])+dynamic->iorder2[4*i+3]-1);
      px = (dynamic->pos2[6*i+3*1+0] -dynamic->pos2[6*i+3*0+0]);
      py = (dynamic->pos2[6*i+3*1+1] -dynamic->pos2[6*i+3*0+1]);
      pz = (dynamic->pos2[6*i+3*1+2] -dynamic->pos2[6*i+3*0+2]);
      m1 = dynamic->m2[2*i+0];
      m2 = dynamic->m2[2*i+1];
      m1 = 1./(sqrt(m1*m2));
#pragma omp parallel for private(k,kx,ky,kz) num_threads(numthread)
      for(k=0;k<realLattice->nlist;k++){
	kx = klist[3*k+0]; ky = klist[3*k+1]; kz = klist[3*k+2];
	tmpdynax[36*k + 6*x + y] += (tt*px)*((m1 * (dynamic->order2[i])))* (cexpf((tt)*(((kx*px)+(ky*py)+(kz*pz)))));
	tmpdynay[36*k + 6*x + y] += (tt*py)*((m1 * (dynamic->order2[i])))* (cexpf((tt)*(((kx*px)+(ky*py)+(kz*pz)))));
	tmpdynaz[36*k + 6*x + y] += (tt*pz)*((m1 * (dynamic->order2[i])))* (cexpf((tt)*(((kx*px)+(ky*py)+(kz*pz)))));
      } 
    }

    float complex tmpy[6],result;
    float alpha = 1.0;
    float beta =0.0;
    for (k=0;k<realLattice->nlist;k++){
      for(i=0;i<6;i++){
	cblas_cgemv(CblasRowMajor,CblasNoTrans,6,6,&alpha,&tmpdynax[36*k],6,&dynamic->eigvec[36*k+i],6,&beta,tmpy,1);
	cblas_cdotc_sub(6,&dynamic->eigvec[36*k+i],6,tmpy,1,&result);
	dynamic->velocity[18*k+6*0+i] = (1./(2.0*dynamic->freq[6*k+i]))*(crealf(result));
	
	
	cblas_cgemv(CblasRowMajor,CblasNoTrans,6,6,&alpha,&tmpdynay[36*k],6,&dynamic->eigvec[36*k+i],6,&beta,tmpy,1);
	cblas_cdotc_sub(6,&dynamic->eigvec[36*k+i],6,tmpy,1,&result);
	dynamic->velocity[18*k+6*1+i] = (1./(2.0*dynamic->freq[6*k+i]))*(crealf(result));
	
	
	cblas_cgemv(CblasRowMajor,CblasNoTrans,6,6,&alpha,&tmpdynaz[36*k],6,&dynamic->eigvec[36*k+i],6,&beta,tmpy,1);
	cblas_cdotc_sub(6,&dynamic->eigvec[36*k+i],6,tmpy,1,&result);
	dynamic->velocity[18*k+6*2+i] = (1./(2.0*dynamic->freq[6*k+i]))*(crealf(result));
	
      }
    }


    delete [] tmpdynax;
    delete [] tmpdynay;
    delete [] tmpdynaz;
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------Reading Force Constants from File-------------------------------------------------------------------------------------
void sub_readPhi(dyna *dynamic){
  dynamic->order2 = new float[dynamic->norder2];
  dynamic->order3 = new float[dynamic->norder3];
  dynamic->order4 = new float[dynamic->norder4];
  int i,j,k;
  i=0; j=0;k=0;
  while((!phi2_in.eof())&&(i<dynamic->norder2)){
    phi2_in>>dynamic->order2[i];
    i++;
  }
  while((!phi3_in.eof())&&(i<dynamic->norder3)){
    phi3_in>>dynamic->order3[j];
    j++;
  }
  while((!phi4_in.eof())&&(i<dynamic->norder4)){
    phi4_in>>dynamic->order4[k];
    k++;
  }
  if((i<dynamic->norder2)||(j<dynamic->norder3)||(k<dynamic->norder4)) cout<<"ERROR: Insufficient force constants in a file"<<endl;
}
//-------------------------------------------------------------------------------------------------------------------------------------

//------------------------GENERATING PRIMITIVE STRUCTURE FOR DYNAMIC MATRIX FROM CONVENTIONAL STRUCTURE----------------------------------------------
void sub_posPrimitive(lattice *realLattice){
  int count;
  float epsi = 1e-6;
  float tmp;
  count =0;
  for(int i=0;i<realLattice->natom;i++){                     // CHECKING NUMBER OF ATOMS
    for (int j=0;j<realLattice->ncell;j++){
      count++;
    }
  }

  realLattice->pR = new float [count*3];                //primitive cell locations for all atoms in supercells
  for(int i=0;i<count;i++){
    tmp = realLattice->pos[3*i+0] - (0.5*realLattice->ax)*lround((realLattice->pos[3*i+0])/(0.5*realLattice->ax));
    tmp = (tmp>0)?(tmp):(-tmp);
    if(tmp<epsi){
      realLattice->index[2*i+1] = 0;
      realLattice->pR[3*i+0] = realLattice->pos[3*i+0]-0;
      realLattice->pR[3*i+1] = realLattice->pos[3*i+1]-0;
      realLattice->pR[3*i+2] = realLattice->pos[3*i+2]-0;
    }else{
      realLattice->index[2*i+1] = 1;
      realLattice->pR[3*i+0] = realLattice->pos[3*i+0]-0.25*realLattice->ax;
      realLattice->pR[3*i+1] = realLattice->pos[3*i+1]-0.25*realLattice->ay;
      realLattice->pR[3*i+2] = realLattice->pos[3*i+2]-0.25*realLattice->az;
    }
  }
}
//-----------------------------------------------------------------------------------------------------------------------------------------

//--------------Creating full displacement list for 2nd,3rd and 4th order-----------------------------------------------------------------------
void sub_fulldisp(lattice *realLattice, dyna *dynamic){
  unsigned int i0[8], index1[5000],neighbour,count1,count2,index2[5000];
  float cutoff;

  //----checking indices for all atoms in central cell-----------------------------------------------------------------
  for(int i=0;i<((realLattice->natom)*(realLattice->ncell));i++){
    if((realLattice->pos[3*i+0]==realLattice->r[3*0+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*0+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*0+2])) i0[0] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*1+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*1+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*1+2])) i0[1] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*2+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*2+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*2+2])) i0[2] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*3+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*3+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*3+2])) i0[3] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*4+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*4+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*4+2])) i0[4] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*5+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*5+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*5+2])) i0[5] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*6+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*6+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*6+2])) i0[6] = realLattice->index[2*i+0];
    if((realLattice->pos[3*i+0]==realLattice->r[3*7+0]) && (realLattice->pos[3*i+1]==realLattice->r[3*7+1])  && (realLattice->pos[3*i+2]==realLattice->r[3*7+2])) i0[7] = realLattice->index[2*i+0];
  }
  /*for(int i=0;i<8;i++){
    cout<<realLattice->pos[3*(i0[i])+0]<<'\t'<<realLattice->pos[3*(i0[i])+1]<<'\t'<<realLattice->pos[3*(i0[i])+2]<<endl;
  }*/
  //------------------------------------------------------------------


  //======================================================================================================================================
  //-------------creating 4th order force constant list for 2 atoms of unit cell-----------------------------------------
  int tmp1,tmp2;
  neighbour = realLattice->nNeighbour4;
  if(neighbour==1) cutoff=0.1876;
  if(neighbour==2) cutoff=0.5001;
  if(neighbour==3) cutoff=0.6876;
  if(neighbour==4) cutoff=1.0001;
  if(neighbour==5) cutoff=1.1876;
  count1 =0; count2=0;
  for(int i=0;i<((realLattice->natom)*(realLattice->ncell));i++){
    
    if(((realLattice->pos[3*i0[0]+0]-realLattice->pos[3*i+0])*(realLattice->pos[3*i0[0]+0]-realLattice->pos[3*i+0]) + (realLattice->pos[3*i0[0]+1]-realLattice->pos[3*i+1])*(realLattice->pos[3*i0[0]+1]-realLattice->pos[3*i+1]) + (realLattice->pos[3*i0[0]+2]-realLattice->pos[3*i+2])*(realLattice->pos[3*i0[0]+2]-realLattice->pos[3*i+2])) < cutoff){
      index1[count1] = realLattice->index[2*i+0];
      count1++;
    }
    
    if(((realLattice->pos[3*i0[1]+0]-realLattice->pos[3*i+0])*(realLattice->pos[3*i0[1]+0]-realLattice->pos[3*i+0]) + (realLattice->pos[3*i0[1]+1]-realLattice->pos[3*i+1])*(realLattice->pos[3*i0[1]+1]-realLattice->pos[3*i+1]) + (realLattice->pos[3*i0[1]+2]-realLattice->pos[3*i+2])*(realLattice->pos[3*i0[1]+2]-realLattice->pos[3*i+2])) < cutoff){
      index2[count2] = realLattice->index[2*i+0];
      count2++;
    }
  }
  tmp1=0; tmp2=0;
  for(int i1 =0; i1<count1;i1++){
    for(int i2=0;i2<count1;i2++){
      for(int i3=0; i3<count1;i3++){
	for(int a=1;a<4;a++){
	  for(int b=1;b<4;b++){
	    for(int c=1;c<4;c++){
	      for(int d=1;d<4;d++){
		fulldisp4_out<<i0[0]<<'\t'<<index1[i1]<<'\t'<<index1[i2]<<'\t'<<index1[i3]<<'\t'<<a<<'\t'<<b<<'\t'<<c<<'\t'<<d<<endl;
		tmp1++;
	      }
	    }
	  }
	}
      }
    }
  }
  for(int i1 =0; i1<count2;i1++){
    for(int i2=0;i2<count2;i2++){
      for(int i3=0; i3<count2;i3++){
	for(int a=1;a<4;a++){
	  for(int b=1;b<4;b++){
	    for(int c=1;c<4;c++){
	      for(int d=1;d<4;d++){
		fulldisp4_out<<i0[1]<<'\t'<<index2[i1]<<'\t'<<index2[i2]<<'\t'<<index2[i3]<<'\t'<<a<<'\t'<<b<<'\t'<<c<<'\t'<<d<<endl;
		tmp2++;
	      }
	    }
	  }
	}
      }
    }
  }

  //------writing same interactions in array------------------------------------------
  dynamic->iorder4 = new unsigned int [8*(tmp1+tmp2)];
  dynamic->norder4 = tmp1+tmp2;
  tmp1=0;
  for(int i1 =0; i1<count1;i1++){
    for(int i2=0;i2<count1;i2++){
      for(int i3=0; i3<count1;i3++){
	for(int a=1;a<4;a++){
	  for(int b=1;b<4;b++){
	    for(int c=1;c<4;c++){
	      for(int d=1;d<4;d++){
		dynamic->iorder4[tmp1*8+0] = i0[0];
		dynamic->iorder4[tmp1*8+1] = index1[i1];
		dynamic->iorder4[tmp1*8+2] = index1[i2];
		dynamic->iorder4[tmp1*8+3] = index1[i3];
		dynamic->iorder4[tmp1*8+4] = a;
		dynamic->iorder4[tmp1*8+5] = b;
		dynamic->iorder4[tmp1*8+6] = c;
		dynamic->iorder4[tmp1*8+7] = d;
		tmp1++;
	      }
	    }
	  }
	}
      }
    }
  }
  for(int i1 =0; i1<count2;i1++){
    for(int i2=0;i2<count2;i2++){
      for(int i3=0; i3<count2;i3++){
	for(int a=1;a<4;a++){
	  for(int b=1;b<4;b++){
	    for(int c=1;c<4;c++){
	      for(int d=1;d<4;d++){
		dynamic->iorder4[tmp1*8+0] = i0[1];
		dynamic->iorder4[tmp1*8+1] = index2[i1];
		dynamic->iorder4[tmp1*8+2] = index2[i2];
		dynamic->iorder4[tmp1*8+3] = index2[i3];
		dynamic->iorder4[tmp1*8+4] = a;
		dynamic->iorder4[tmp1*8+5] = b;
		dynamic->iorder4[tmp1*8+6] = c;
		dynamic->iorder4[tmp1*8+7] = d;
		tmp1++;
	      }
	    }
	  }
	}
      }
    }
  }
  //--------------------------------------------------------------------------------------------------------------------
  //===================================================================================================================================


  //======================================================================================================================================
  //-------------creating 3rd order force constant list for 2 atoms of unit cell-----------------------------------------
  neighbour = realLattice->nNeighbour3;
  if(neighbour==1) cutoff=0.1876;
  if(neighbour==2) cutoff=0.5001;
  if(neighbour==3) cutoff=0.6876;
  if(neighbour==4) cutoff=1.0001;
  if(neighbour==5) cutoff=1.1876;
  count1 =0; count2=0;
  for(int i=0;i<((realLattice->natom)*(realLattice->ncell));i++){
    
    if(((realLattice->pos[3*i0[0]+0]-realLattice->pos[3*i+0])*(realLattice->pos[3*i0[0]+0]-realLattice->pos[3*i+0]) + (realLattice->pos[3*i0[0]+1]-realLattice->pos[3*i+1])*(realLattice->pos[3*i0[0]+1]-realLattice->pos[3*i+1]) + (realLattice->pos[3*i0[0]+2]-realLattice->pos[3*i+2])*(realLattice->pos[3*i0[0]+2]-realLattice->pos[3*i+2])) < cutoff){
      index1[count1] = realLattice->index[2*i+0];
      count1++;
    }
    
    if(((realLattice->pos[3*i0[1]+0]-realLattice->pos[3*i+0])*(realLattice->pos[3*i0[1]+0]-realLattice->pos[3*i+0]) + (realLattice->pos[3*i0[1]+1]-realLattice->pos[3*i+1])*(realLattice->pos[3*i0[1]+1]-realLattice->pos[3*i+1]) + (realLattice->pos[3*i0[1]+2]-realLattice->pos[3*i+2])*(realLattice->pos[3*i0[1]+2]-realLattice->pos[3*i+2])) < cutoff){
      index2[count2] = realLattice->index[2*i+0];
      count2++;
    }
  }
  tmp1=0;tmp2=0;
  for(int i1 =0; i1<count1;i1++){
    for(int i2=0;i2<count1;i2++){
      for(int a=1;a<4;a++){
	for(int b=1;b<4;b++){
	  for(int c=1;c<4;c++){
	    fulldisp3_out<<i0[0]<<'\t'<<index1[i1]<<'\t'<<index1[i2]<<'\t'<<a<<'\t'<<b<<'\t'<<c<<endl;
	    tmp1++;
	  }
	}
      }
    }
  }
  for(int i1 =0; i1<count2;i1++){
    for(int i2=0;i2<count2;i2++){
	for(int a=1;a<4;a++){
	  for(int b=1;b<4;b++){
	    for(int c=1;c<4;c++){
		fulldisp3_out<<i0[1]<<'\t'<<index2[i1]<<'\t'<<index2[i2]<<'\t'<<a<<'\t'<<b<<'\t'<<c<<endl;
		tmp2++;
	      }
	    }
	  }
	}
  }

  // writing the same output in array
  dynamic->iorder3 = new unsigned int [6*(tmp1+tmp2)];
  dynamic->norder3 = tmp1+tmp2;
  tmp1=0;
  for(int i1 =0; i1<count1;i1++){
    for(int i2=0;i2<count1;i2++){
      for(int a=1;a<4;a++){
	for(int b=1;b<4;b++){
	  for(int c=1;c<4;c++){
	    dynamic->iorder3[tmp1*6+0] = i0[0];
	    dynamic->iorder3[tmp1*6+1] = index1[i1];
	    dynamic->iorder3[tmp1*6+2] = index1[i2];
	    dynamic->iorder3[tmp1*6+3] = a;
	    dynamic->iorder3[tmp1*6+4] = b;
	    dynamic->iorder3[tmp1*6+5] = c;
	    tmp1++;
	  }
	}
      }
    }
  }
  for(int i1 =0; i1<count2;i1++){
    for(int i2=0;i2<count2;i2++){
	for(int a=1;a<4;a++){
	  for(int b=1;b<4;b++){
	    for(int c=1;c<4;c++){
	      dynamic->iorder3[tmp1*6+0] = i0[1];
	      dynamic->iorder3[tmp1*6+1] = index2[i1];
	      dynamic->iorder3[tmp1*6+2] = index2[i2];
	      dynamic->iorder3[tmp1*6+3] = a;
	      dynamic->iorder3[tmp1*6+4] = b;
	      dynamic->iorder3[tmp1*6+5] = c;
	      tmp1++;
	      }
	    }
	  }
	}
  }
  //--------------------------------------------------------------------------------------------------------------------
  //===================================================================================================================================


  //======================================================================================================================================
  //-------------creating 2nd order force constant list for 2 atoms of unit cell-----------------------------------------
  neighbour = realLattice->nNeighbour2;
  if(neighbour==1) cutoff=0.1876;
  if(neighbour==2) cutoff=0.5001;
  if(neighbour==3) cutoff=0.6876;
  if(neighbour==4) cutoff=1.0001;
  if(neighbour==5) cutoff=1.1876;
  count1 =0; count2=0;
  for(int i=0;i<((realLattice->natom)*(realLattice->ncell));i++){
    
    if(((realLattice->pos[3*i0[0]+0]-realLattice->pos[3*i+0])*(realLattice->pos[3*i0[0]+0]-realLattice->pos[3*i+0]) + (realLattice->pos[3*i0[0]+1]-realLattice->pos[3*i+1])*(realLattice->pos[3*i0[0]+1]-realLattice->pos[3*i+1]) + (realLattice->pos[3*i0[0]+2]-realLattice->pos[3*i+2])*(realLattice->pos[3*i0[0]+2]-realLattice->pos[3*i+2])) < cutoff){
      index1[count1] = realLattice->index[2*i+0];
      count1++;
    }
   
    if(((realLattice->pos[3*i0[1]+0]-realLattice->pos[3*i+0])*(realLattice->pos[3*i0[1]+0]-realLattice->pos[3*i+0]) + (realLattice->pos[3*i0[1]+1]-realLattice->pos[3*i+1])*(realLattice->pos[3*i0[1]+1]-realLattice->pos[3*i+1]) + (realLattice->pos[3*i0[1]+2]-realLattice->pos[3*i+2])*(realLattice->pos[3*i0[1]+2]-realLattice->pos[3*i+2])) < cutoff){
      index2[count2] = realLattice->index[2*i+0];
      count2++;
    }
  }
  tmp1=0;tmp2=0;
  for(int i1 =0; i1<count1;i1++){
    for(int a=1;a<4;a++){
      for(int b=1;b<4;b++){
	fulldisp2_out<<i0[0]<<'\t'<<index1[i1]<<'\t'<<a<<'\t'<<b<<endl;
	tmp1++;
      }
    }
  }
  for(int i1 =0; i1<count2;i1++){
    for(int a=1;a<4;a++){
      for(int b=1;b<4;b++){
	fulldisp2_out<<i0[1]<<'\t'<<index2[i1]<<'\t'<<a<<'\t'<<b<<endl;
	tmp2++;
      }
    }
  }

  //writing the same thing in array
  dynamic->iorder2 = new unsigned int [4*(tmp1+tmp2)];
  dynamic->norder2 = tmp1+tmp2;
  tmp1=0;
  for(int i1 =0; i1<count1;i1++){
    for(int a=1;a<4;a++){
      for(int b=1;b<4;b++){
	dynamic->iorder2[4*tmp1+0] = i0[0];
	dynamic->iorder2[4*tmp1+1] = index1[i1];
	dynamic->iorder2[4*tmp1+2] = a;
	dynamic->iorder2[4*tmp1+3] = b;
	tmp1++;
      }
    }
  }
  for(int i1 =0; i1<count2;i1++){
    for(int a=1;a<4;a++){
      for(int b=1;b<4;b++){
	dynamic->iorder2[4*tmp1+0] = i0[1];
	dynamic->iorder2[4*tmp1+1] = index2[i1];
	dynamic->iorder2[4*tmp1+2] = a;
	dynamic->iorder2[4*tmp1+3] = b;
	tmp1++;
      }
    }
  }
  //--------------------------------------------------------------------------------------------------------------------
  //===================================================================================================================================

}
//-----------------------------------------------------------------------------------------------------------------------------

//------------full info of displacement list------------------------------------------------------------------------------------------
void sub_info(lattice *realLattice, dyna *dynamic){
  dynamic->pos2 = new float [6*dynamic->norder2];
  dynamic->pos3 = new float [9*dynamic->norder3];
  dynamic->pos4 = new float [12*dynamic->norder4];
  dynamic->m2 = new float [2*dynamic->norder2];
  dynamic->m3 = new float [3*dynamic->norder3];
  dynamic->m4 = new float [4*dynamic->norder4];

  for(int i=0;i<dynamic->norder2;i++){             // i is the index of disp list...j is the coloumn in the list...and then 3 directions for it
    for(int j=0;j<2;j++){
      dynamic->pos2[6*i + 3*j + 0] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder2[4*i+j])+0])+0]);
      dynamic->pos2[6*i + 3*j + 1] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder2[4*i+j])+0])+1]);
      dynamic->pos2[6*i + 3*j + 2] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder2[4*i+j])+0])+2]);
      dynamic->m2[2*i+j] = realLattice->m[realLattice->index[2*(dynamic->iorder2[4*i+j])+1]];
    }
  }

  for(int i=0;i<dynamic->norder3;i++){
    for(int j=0;j<3;j++){
      dynamic->pos3[9*i + 3*j + 0] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder3[6*i+j])+0])+0]);
      dynamic->pos3[9*i + 3*j + 1] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder3[6*i+j])+0])+1]);
      dynamic->pos3[9*i + 3*j + 2] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder3[6*i+j])+0])+2]);
      dynamic->m3[3*i+j] = realLattice->m[realLattice->index[2*(dynamic->iorder3[6*i+j])+1]];
    }
  }

  for(int i=0;i<dynamic->norder4;i++){
    for(int j=0;j<4;j++){
      dynamic->pos4[12*i + 3*j + 0] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder4[8*i+j])+0])+0]);
      dynamic->pos4[12*i + 3*j + 1] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder4[8*i+j])+0])+1]);
      dynamic->pos4[12*i + 3*j + 2] = (realLattice->pos[3*(realLattice->index[2*(dynamic->iorder4[8*i+j])+0])+2]);
      dynamic->m4[4*i+j] = realLattice->m[realLattice->index[2*(dynamic->iorder4[8*i+j])+1]];
    }
  }

  
  
  dynamic->info2 = new unsigned int [2*dynamic->norder2]; //1st two coloumns are atom type (0 or 1 in diamond structure)
  dynamic->info3 = new unsigned int [3*dynamic->norder3];
  dynamic->info4 = new unsigned int [4*dynamic->norder4];
  
  for (int i=0;i<dynamic->norder2;i++){
    for(int j=0;j<2;j++){
      dynamic->info2[2*i+j] = realLattice->index[2*(dynamic->iorder2[4*i+j])+1];
    }
  }

  for (int i=0;i<dynamic->norder3;i++){
    for(int j=0;j<3;j++){
      dynamic->info3[3*i+j] = realLattice->index[2*(dynamic->iorder3[6*i+j])+1];
    }
  }
  for (int i=0;i<dynamic->norder4;i++){
    for(int j=0;j<4;j++){
      dynamic->info4[4*i+j] = realLattice->index[2*(dynamic->iorder4[8*i+j])+1];
    }
  }
  

}
//---------------------------------------------------------------------------------------------------------------------------------------

//-----------------------writing position for full list sorted in order of distance from center--------------------------------------
void sub_posIndex(lattice *realLattice){
  /*SPECIFIC FOR DIAMOND STRUCTURE WITH SAME ATOMS ONLY */

  unsigned int count;
  float *tmp;

  //=======creating position file================================================
  count =0;
  for(int i=0;i<realLattice->natom;i++){
    for (int j=0;j<realLattice->ncell;j++){
      count++;
    }
  }
  realLattice->pos = new float [count*3];                       //positions of all atoms arranged as their distance from origin....
  realLattice->index = new unsigned int [2*count];              // 1st column as index
  tmp = new float [count];

  count=0;
  for(int i=0;i<realLattice->natom;i++){
    for (int j=0;j<realLattice->ncell;j++){
      realLattice->pos[3*count+0] = realLattice->R[3*j+0]+realLattice->r[3*i+0];
      realLattice->pos[3*count+1] = realLattice->R[3*j+1]+realLattice->r[3*i+1];
      realLattice->pos[3*count+2] = realLattice->R[3*j+2]+realLattice->r[3*i+2];
      tmp[count] = realLattice->pos[3*count+0]*realLattice->pos[3*count+0] + realLattice->pos[3*count+1]*realLattice->pos[3*count+1] + realLattice->pos[3*count+2]*realLattice->pos[3*count+2];
      count++;
    }
  }
  //======================================================================================


  //sorting distance wise-----------------------------------------------------------------
  bool check;
  float tmpm,tmpx,tmpy,tmpz;
  do{
    check =true;
    for(int i=0;i<count-1;i++){
      if(tmp[i+1]<tmp[i]){
	tmpm = tmp[i]; tmpx = realLattice->pos[3*i+0]; tmpy = realLattice->pos[3*i+1]; tmpz = realLattice->pos[3*i+2];
	tmp[i] = tmp[i+1]; realLattice->pos[3*(i)+0] = realLattice->pos[3*(i+1)+0]; realLattice->pos[3*(i)+1] = realLattice->pos[3*(i+1)+1];  realLattice->pos[3*(i)+2] = realLattice->pos[3*(i+1)+2];
	tmp[i+1] = tmpm; realLattice->pos[3*(i+1)+0] = tmpx; realLattice->pos[3*(i+1)+1] = tmpy; realLattice->pos[3*(i+1)+2] = tmpz;
	check =false;
      }
    }
  }while(check==false);
  for(int i=0;i<count;i++){
    realLattice->index[2*i+0] = i;
  }
  //------------------------------------------------------------------------------------

  // writing positions............
  for(int i=0;i<count;i++){
    fullpos_out<<realLattice->index[2*i+0]<<'\t';
    fullpos_out<<realLattice->pos[3*i+0]<<'\t';
    fullpos_out<<realLattice->pos[3*i+1]<<'\t';
    fullpos_out<<realLattice->pos[3*i+2]<<'\t';
    fullpos_out<<tmp[i]<<'\n';
  }

  delete [] tmp;
}
//-----------------------------------------------------------------------------------------------------------------------------

//---------------------SEARCHING FOR GIVEN VALUE IN A LIST OF POINTS----------------------------------------------------------------------------
int sub_search(long int *sklist,int s, int e, long int tmp){
  // this subroutine does searching only on intergers....
  int out,m;
  if((s-e)>0) return -1;
  
  m = floor((s+e)/2);
  if(sklist[m]==tmp) return m;
  //if((sklist[m]>=(tmp-(1e-2)))&&(sklist[m]<=(tmp+(1e-2)))) return m;
  if(sklist[m]>tmp) out = sub_search(sklist,s,m-1,tmp);
  if(sklist[m]<tmp) out = sub_search(sklist,m+1,e,tmp);

  return out; 
}
//-------------------------------------------------------------------------------------------------------------------------------------------------

//-------------------- CHECKING MOMENTUM CONSERVATION K1+K2+K3-G = 0-------------------------------------------------------------------
int sub_kinteraction(float *klist,lattice *realLattice, float *kinterac, unsigned short int *ikinterac){
  /*.......................This Subrotuine is for fcc only with primitive unit cell................................*/
  int ninterac = 0;
  long int *sklist;
  unsigned short int *track;
  sklist = new long int [realLattice->nlist];
  track =  new unsigned short int [realLattice->nlist];

  //=====generating sklist=================================
  long int mx,my,mz;
  mx =1000; my = 1000000; mz =1000000000;
  for(int i=realLattice->nlist-1; i>=0; --i){
    sklist[i] = lround(mx*klist[3*i+0]) + lround(my*klist[3*i+1]) + lround(mz*klist[3*i+2]);
    track[i] = i;
    //data_out<<sklist[i]<<'\n';
  }
  //=========================================================
  
  //=====sorting the sklist in ascending order
  bool check;
  long int tmp;
  int t;
  do{
    check =true;
    for(int i=realLattice->nlist-2;i>=0;--i){
      if(sklist[i+1]<sklist[i]){
	tmp = sklist[i+1];
	t = track[i+1];
	sklist[i+1] = sklist[i];
	track[i+1] = track[i];
	sklist[i] = tmp;
	track[i] = t;
	check =false;
      }
    }
  }while(check==false);
  //============================================

  //=======STARTING CHECKING MOMENTUM===========
  long int tmpx,tmpy,tmpz,tmp1,tmp2,tmp3;
  long int *dtmp;
  int res,s,e,i1,i2,ginterac,gsize,count,count1;
  ginterac = 2;
  i2=0;
  gsize= round(pow((((ginterac)*2)+1),3));
  dtmp = new long int [gsize];
  for (int r1=-ginterac;r1<=ginterac;++r1){                             // G vectors to check with.....everything is to be scaled by 2*pi/ax
    for(int r2=-ginterac;r2<=ginterac;++r2){
      for(int r3=-ginterac;r3<=ginterac;++r3){
	tmpx = lround(mx*((-1)*r1 + (1)*r2 + (1)*r3));
	tmpy = lround(my*((1)*r1 + (-1)*r2 + (1)*r3));
	tmpz = lround(mz*((1)*r1 + (1)*r2 + (-1)*r3));
	tmp = tmpx+tmpy+tmpz;                                          //desired value from combination of sklist
	dtmp[i2] = tmp;
	i2++;
      }
    }
  }
  //for(i1=0;i1<125;i1++) data_out<<dtmp[i1]<<endl;

  // 6 POSSIBLE CASES FOR 3 PAIR INTERACTION ----------
  int *type_interac;
  type_interac = new int [6*3];
  type_interac[3*0+0] = 1; type_interac[3*0+1] = 1; type_interac[3*0+2] = -1;
  type_interac[3*1+0] = -1; type_interac[3*1+1] = 1; type_interac[3*1+2] = 1;
  type_interac[3*2+0] = 1; type_interac[3*2+1] = -1; type_interac[3*2+2] = 1;
  type_interac[3*3+0] = 1; type_interac[3*3+1] = -1; type_interac[3*3+2] = -1;
  type_interac[3*4+0] = -1; type_interac[3*4+1] = 1; type_interac[3*4+2] = -1;
  type_interac[3*5+0] = 1; type_interac[3*5+1] = 1; type_interac[3*5+2] = 1;

  //array to check if there is repetition......
  long int *repet;
  repet = new long int [realLattice->nlist];
  int e1,s1;
  long int res1;

#pragma omp parallel for private(i1,i2,tmp1,tmp2,tmp3,s,e,res,check,count,count1,res1,s1,e1,repet) num_threads(numthread)
	//===========1st case=============
	for(i1 = realLattice->nlist-1;i1>=0;--i1){
	  repet = new long int [realLattice->nlist];
	  tmp1 = sklist[i1];
	  for(i2 = i1;i2>=0;--i2){
	    count=0;
	    e1 = 0;s1=0;
	    repet[0]=0;
	    do{
	      count1=0;
	      do{
		tmp2 = sklist[i2];
		tmp3 = type_interac[3*count1+0]*tmp1 + type_interac[3*count1+1]*tmp2 + type_interac[3*count1+2]*dtmp[count];
		s = 0; e = i2;
		res = sub_search(sklist,s,e,tmp3);
		if(res>=0){
		  if(e1==0) res1 =-1;
		  else res1=sub_search(repet,s1,e1,res);
		  if(res1<0){		
#pragma omp critical(update)
{
		    //kinterac[9*ninterac+0] = klist[3*track[i1]+0]; kinterac[9*ninterac+1] = klist[3*track[i1]+1]; kinterac[9*ninterac+2] = klist[3*track[i1]+2];
		    //kinterac[9*ninterac+3] = klist[3*track[i2]+0]; kinterac[9*ninterac+4] = klist[3*track[i2]+1]; kinterac[9*ninterac+5] = klist[3*track[i2]+3];
		    //kinterac[9*ninterac+6] = klist[3*track[res]+0]; kinterac[9*ninterac+7] = klist[3*track[res]+1]; kinterac[9*ninterac+8] = klist[3*track[res]+2];
		    ikinterac[3*ninterac+0] = track[i1]; ikinterac[3*ninterac+1] = track[i2]; ikinterac[3*ninterac+2] = track[res];
		    ninterac++;
		    repet[e1]=res;
		    e1++;
}
		}
	      }
	      count1++;
	      }while((count1<6));
	      count++;
	    }while((count<gsize));
	  }
	}
	//================================
  //============================================

  
  delete [] sklist;
  delete [] track;
  delete [] dtmp;
  delete [] type_interac;
  delete [] repet;
  return ninterac;
}
//------------------------------------------------------------------------------------------------------------------------------------------------

//----------------scaling k values by 2*pi/ax--------------------------------------------------------------------------------------------------
void sub_kscale(float *klist,lattice *realLattice){
  for(int i=0;i<realLattice->nlist;i++){
    klist[3*i+0] *= 2.*pi/(realLattice->ax);
    klist[3*i+1] *= 2.*pi/(realLattice->ay);
    klist[3*i+2] *= 2.*pi/(realLattice->az); 
  }
}
//---------------------------------------------------------------------------------------------------------------------------------------------

//---------------------------------- CONSTRUCTING RECIPROCAL STRUCTURE-----------------------------------------------------------------------------
void sub_klist(float *klist,lattice *realLattice){
  //this subroutine is for fcc with primitive unit cell only.....
  float b1[3],b2[3],b3[3];


  if((realLattice->type==2)&&(realLattice->isConv==0)){                                        // primitive fcc cell
    b1[0] = -1.; b1[1] = 1.; b1[2] = 1.;
    b2[0] = 1.; b2[1] = -1.; b2[2] = 1.;
    b3[0] = 1.; b3[1] = 1.; b3[2] = -1.;
    int i=0;
    for(int i1 = -round(realLattice->kx/2)+1; i1<round(realLattice->kx/2)+1;i1++){
      for(int i2 = -round(realLattice->ky/2)+1; i2<round(realLattice->ky/2)+1;i2++){
        for(int i3 = -round(realLattice->kz/2)+1; i3<round(realLattice->kz/2)+1;i3++){
          klist[3*i+0] = ((i1*b1[0])/(realLattice->kx)) + ((i2*b2[0])/(realLattice->ky)) +((b3[0]*i3)/(realLattice->kz));
          klist[3*i+1] = ((i1*b1[1])/(realLattice->kx)) + ((i2*b2[1])/(realLattice->ky)) +((b3[1]*i3)/(realLattice->kz));
          klist[3*i+2] = ((i1*b1[2])/(realLattice->kx)) + ((i2*b2[2])/(realLattice->ky)) +((b3[2]*i3)/(realLattice->kz));
          i++;
        }
      }
    }

    //   checking if point is in first brillioun zone
    float p [14][3];
    p[0][0] = 1.; p[0][1]=1.; p[0][2]=1.;
    p[1][0] = 1.; p[1][1]=1.; p[1][2]=-1.;
    p[2][0] = 1.; p[2][1]=-1.; p[2][2]=1.;
    p[3][0] = 1.; p[3][1]=-1.; p[3][2]=-1.;
    p[4][0] = -1.; p[4][1]=1.; p[4][2]=1.;
    p[5][0] = -1.; p[5][1]=1.; p[5][2]=-1.;
    p[6][0] = -1.; p[6][1]=-1.; p[6][2]=1.;
    p[7][0] = -1.; p[7][1]=-1.; p[7][2]=-1.;
    p[8][0] =2*1.; p[8][1] = 0; p[8][2]=0;
    p[9][0] =-2*1.; p[9][1] = 0; p[9][2]=0;
    p[10][0]=0; p[10][1] = 2*1.; p[10][2]=0;
    p[11][0] =0; p[11][1] = -2*1.; p[11][2]=0;
    p[12][0] =0; p[12][1] = 0; p[12][2]=2*1.;
    p[13][0] =0; p[13][1] = 0; p[13][2]=-2*1.;

    bool check;
    float tmp1,tmp2;
    for(int i1 = 0; i1<realLattice->nlist;i1++){
      do{
        check = true;
        for(int i2=0;i2<14;i2=i2+2){
          tmp1 = pow((klist[3*i1+0] - p[i2][0]),2) + pow((klist[3*i1+1] - p[i2][1]),2) + pow((klist[3*i1+2] - p[i2][2]),2);
          tmp2 = pow((klist[3*i1+0] ),2) + pow((klist[3*i1+1]),2) + pow((klist[3*i1+2] ),2);
          if(tmp2>tmp1){
            check = false;
            klist[3*i1+0] -=p[i2][0];
            klist[3*i1+1] -=p[i2][1];
            klist[3*i1+2] -=p[i2][2];
          }
        }
        for(int i2=1;i2<14;i2=i2+2){
          tmp1 = pow((klist[3*i1+0] - p[i2][0]),2) + pow((klist[3*i1+1] - p[i2][1]),2) + pow((klist[3*i1+2] - p[i2][2]),2);
          tmp2 = pow((klist[3*i1+0] ),2) + pow((klist[3*i1+1]),2) + pow((klist[3*i1+2] ),2);
          if(tmp2>tmp1){
            check = false;
            klist[3*i1+0] -=p[i2][0];
            klist[3*i1+1] -=p[i2][1];
            klist[3*i1+2] -=p[i2][2];
          }
        }
      }while(check==false);
    }
  }
}
//---------------------------------------------------------------------------------------------------------------------------------------------------

//---------------------- constructing real lattice----------------------------------------------------------------------------------------------
void sub_realStructure(lattice *realLattice){
  //this is a general subroutine....valid for all types and formats.....
  
  
  std::string line;
  unsigned short int type,isConv;

  std::getline(data_in,line);
  
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> realLattice->ax >> realLattice->ay >> realLattice->az;                      // unit cell size in x,y,z direction

  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> type;                                                          // lattice type
 
  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> isConv;                                                          // unit cell  type
  
  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> realLattice->natom;                                               // # atoms in unit cell
  
  realLattice->r = new float [realLattice->natom*3];
  realLattice->m = new float [realLattice->natom];

  if(realLattice->natom==2){
    std::getline(data_in,line);
    std::getline(data_in,line);
    std::getline(data_in,line);
    data_in>> realLattice->r[3*0+0] >> realLattice->r[3*0+1] >> realLattice->r[3*0+2] >> realLattice->m[0];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*1+0] >> realLattice->r[3*1+1] >> realLattice->r[3*1+2] >> realLattice->m[1];
  }

  if(realLattice->natom==8){
    std::getline(data_in,line);
    std::getline(data_in,line);
    std::getline(data_in,line);
    data_in>> realLattice->r[3*0+0] >> realLattice->r[3*0+1] >> realLattice->r[3*0+2] >> realLattice->m[0];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*1+0] >> realLattice->r[3*1+1] >> realLattice->r[3*1+2] >> realLattice->m[1];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*2+0] >> realLattice->r[3*2+1] >> realLattice->r[3*2+2] >> realLattice->m[2];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*3+0] >> realLattice->r[3*3+1] >> realLattice->r[3*3+2] >> realLattice->m[3];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*4+0] >> realLattice->r[3*4+1] >> realLattice->r[3*4+2] >> realLattice->m[4];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*5+0] >> realLattice->r[3*5+1] >> realLattice->r[3*5+2] >> realLattice->m[5];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*6+0] >> realLattice->r[3*6+1] >> realLattice->r[3*6+2] >> realLattice->m[6];
    std::getline(data_in,line);
    data_in>> realLattice->r[3*7+0] >> realLattice->r[3*7+1] >> realLattice->r[3*7+2] >> realLattice->m[7];
  }
  //cout<<realLattice->r[3*7+0]<<'\t'<<realLattice->r[3*7+1]<<'\t'<<realLattice->r[3*7+2]<<endl;
  
  
  realLattice->r[3*0+0] *= realLattice->ax; realLattice->r[3*1+0] *= realLattice->ax;
  realLattice->r[3*0+1] *= realLattice->ay; realLattice->r[3*1+1] *= realLattice->ay;
  realLattice->r[3*0+2] *= realLattice->az; realLattice->r[3*1+2] *= realLattice->az;             // converting fractional coordinate into real coordinate
  
  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> realLattice->Nx>>realLattice->Ny>>realLattice->Nz>>realLattice->nNx>>realLattice->nNy>>realLattice->nNz;                                                            // # unit cells in each direction
  //realLattice->Nx = (realLattice->Nx/2); realLattice->Ny = (realLattice->Ny/2); realLattice->Nz = (realLattice->Nz/2);
  
  
  float a1[3],a2[3],a3[3];
  if((isConv==0)&&(type=2)){                                                        // lattice vectors for primitive fcc cell
    a1[0] = 1.0; a1[1] = 0.0; a1[2] = 0.0;
    a2[0] = 0.0; a2[1] = 1.0; a2[2] = 0.0;
    a3[0] = 0.0; a3[1] = 0.0; a3[2] = 1.0;
  }

  realLattice->ncell = (((realLattice->Nx+realLattice->nNx+1)*(realLattice->Ny+realLattice->nNy+1)*(realLattice->Nz+realLattice->nNz+1)));                                        // 8 because 2*2*2 as realLattice->Nx =realLattice->Nx_required/2 and 1 to include central cell as well
  
  realLattice->R = new float [(realLattice->ncell+1)*3];
  realLattice->R[3*0+0] = 0.0;
  realLattice->R[3*0+1] = 0.0;
  realLattice->R[3*0+1] = 0.0;                                               // central cell
  int i=1;                                                               // generating cloud around central cell.
  
  for(int ix = -realLattice->nNx; ix<realLattice->Nx+1;ix++){
    for(int iy = -realLattice->nNy; iy<realLattice->Ny+1;iy++){
      for(int iz = -realLattice->nNz; iz<realLattice->Nz+1;iz++){
	if(!((ix==0)&&(iy==0)&&(iz==0))){
	  realLattice->R[3*i+0] = realLattice->ax*(ix*a1[0] + iy*a2[0] + iz*a3[0]);
	  realLattice->R[3*i+1] = realLattice->ay*(ix*a1[1] + iy*a2[1] + iz*a3[1]);
	  realLattice->R[3*i+2] = realLattice->az*(ix*a1[2] + iy*a2[2] + iz*a3[2]);
	  i++;
	}
      }
    } 
  }
  
  
  realLattice->Nx *= 2 ;
  realLattice->Ny *= 2 ;
  realLattice->Nz *= 2 ;
  realLattice->type = type;
  realLattice->isConv = isConv;

  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>>realLattice->kx>>realLattice->ky>>realLattice->kz;
  realLattice->nlist = (realLattice->kx*realLattice->ky*realLattice->kz);
  realLattice->kx_scale = 2.*pi/(realLattice->ax);
  realLattice->ky_scale = 2.*pi/(realLattice->ay);
  realLattice->kz_scale = 2.*pi/(realLattice->az);

  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> numthread;
  //cout<<realLattice->ncell<<endl;

  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> realLattice->nNeighbour2>> realLattice->nNeighbour3>> realLattice->nNeighbour4;
  //cout<<realLattice->nNeighbour<<endl;

  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> temperature;

  std::getline(data_in,line);
  std::getline(data_in,line);
  std::getline(data_in,line);
  data_in>> FC_available;   // checking whether to run full code or only FC part...
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
//=================================================================================================================================================
